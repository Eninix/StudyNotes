[TOC]

---

# **1.Node.js**

## 1.1模块化

### 1.1.1自己的模块

![image-20210120172305842](assets.%E7%AC%94%E8%AE%B0/image-20210120172305842.png)![image-20210120172325805](assets.%E7%AC%94%E8%AE%B0/image-20210120172325805.png)![image-20210120172344485](assets.%E7%AC%94%E8%AE%B0/image-20210120172344485.png)



### 1.1.2系统模块 fs - 文件操作

#### 读取文件

![image-20210120172518141](assets.%E7%AC%94%E8%AE%B0/image-20210120172518141.png)

![image-20210120172620071](assets.%E7%AC%94%E8%AE%B0/image-20210120172620071.png)

#### 写入文件

![image-20210120173549334](assets.%E7%AC%94%E8%AE%B0/image-20210120173549334.png)

### 1.1.3系统文件 path - 路径操作

#### 路径拼接

![image-20210120175725600](assets.%E7%AC%94%E8%AE%B0/image-20210120175725600.png)

#### 相对路径与绝对路径

![image-20210120175922648](assets.%E7%AC%94%E8%AE%B0/image-20210120175922648.png)

## 1.2第三方模块 nodemon 保存后自动运行

![image-20210120181708589](assets.%E7%AC%94%E8%AE%B0/image-20210120181708589.png)

## 1.3第三方模块 nrm 切换国内下载地址

![image-20210120182005767](assets.%E7%AC%94%E8%AE%B0/image-20210120182005767.png)

## 1.4第三方模块 gulp

![image-20210120182916245](assets.%E7%AC%94%E8%AE%B0/image-20210120182916245.png)

![image-20210120183747401](assets.%E7%AC%94%E8%AE%B0/image-20210120183747401.png)

### 初次使用

![image-20210120184939686](assets.%E7%AC%94%E8%AE%B0/image-20210120184939686.png)

![image-20210120184859782](assets.%E7%AC%94%E8%AE%B0/image-20210120184859782.png)

### 新版本写法

![image-20210120201637604](assets.%E7%AC%94%E8%AE%B0/image-20210120201637604.png)

### gulp插件

![image-20210120185054619](assets.%E7%AC%94%E8%AE%B0/image-20210120185054619.png)

### 压缩html文件 gulp-htmlmin

需要在gulpfile.js中这样写道

![image-20210120191729326](assets.%E7%AC%94%E8%AE%B0/image-20210120191729326.png)

![image-20210120191654988](assets.%E7%AC%94%E8%AE%B0/image-20210120191654988.png)



### 抽取公共部分 gulp-file-include

需要在gulpfile.js中这样写道

![image-20210120191810010](assets.%E7%AC%94%E8%AE%B0/image-20210120191810010.png)

![image-20210120191903195](assets.%E7%AC%94%E8%AE%B0/image-20210120191903195.png)

需要在html中这样书写公共部分，将公共部分单独建立文件，可同时插入到多个html中

![image-20210120192048251](assets.%E7%AC%94%E8%AE%B0/image-20210120192048251.png)

### 压缩less与css

向安装下列插件

![image-20210120192801351](assets.%E7%AC%94%E8%AE%B0/image-20210120192801351.png)

需要在gulpfile.js中这样写道

![image-20210120192717437](assets.%E7%AC%94%E8%AE%B0/image-20210120192717437.png)

![image-20210120192900861](assets.%E7%AC%94%E8%AE%B0/image-20210120192900861.png)

### js语法转换

*向安装下列插件*

npm install gulp-babel @babel/core @babel/preset-env

```
npm install --save-dev gulp-babel @babel/core @babel/preset-env
```

npm install gulp-uglify

需要在gulpfile.js中这样写道

![image-20210120194148099](assets.%E7%AC%94%E8%AE%B0/image-20210120194148099.png)

![image-20210120194457041](assets.%E7%AC%94%E8%AE%B0/image-20210120194457041.png)

![image-20210120194523610](assets.%E7%AC%94%E8%AE%B0/image-20210120194523610.png)

### 复制文件夹

即什么都不做，直接dest

![image-20210120200412150](assets.%E7%AC%94%E8%AE%B0/image-20210120200412150.png)

### 构建任务

![image-20210120201540044](assets.%E7%AC%94%E8%AE%B0/image-20210120201540044.png)

## 1.5package.json文件

使用 npm init -y快速生成该文件
记录了项目使用的模块及其相应的版本
通过 npm install 可以快速下载package.json中记录的相应版本模块

### 项目依赖和开发依赖

npm install						会下载全部的依赖
npm install --production	只下载项目依赖

![image-20210122161144397](assets.%E7%AC%94%E8%AE%B0/image-20210122161144397.png)

### 起别名批量执行代码

使用“npm run 别名“即可执行代码

![image-20210122163840143](assets.%E7%AC%94%E8%AE%B0/image-20210122163840143.png)

## 1.6Node.js模块查找机制

![image-20210122164136798](assets.%E7%AC%94%E8%AE%B0/image-20210122164136798.png)

![image-20210122180038220](assets.%E7%AC%94%E8%AE%B0/image-20210122180038220.png)

# 2.**服务器与客户端**

## 2.1创建Web服务器

![image-20210122183951936](assets.%E7%AC%94%E8%AE%B0/image-20210122183951936.png)![image-20210122193506300](assets.%E7%AC%94%E8%AE%B0/image-20210122193506300.png)

## 2.2请求报文

![image-20210122193136965](assets.%E7%AC%94%E8%AE%B0/image-20210122193136965.png)

![image-20210122195747217](assets.%E7%AC%94%E8%AE%B0/image-20210122195747217.png)![image-20210122195802074](assets.%E7%AC%94%E8%AE%B0/image-20210122195802074.png)

## 2.3响应报文

![image-20210122200720418](assets.%E7%AC%94%E8%AE%B0/image-20210122200720418.png)

![image-20210123133717377](assets.%E7%AC%94%E8%AE%B0/image-20210123133717377.png)

## 2.4请求参数

### get请求参数

![image-20210123140112320](assets.%E7%AC%94%E8%AE%B0/image-20210123140112320.png)

![image-20210123135929819](assets.%E7%AC%94%E8%AE%B0/image-20210123135929819.png)

### post请求参数

![image-20210123144234573](assets.%E7%AC%94%E8%AE%B0/image-20210123144234573.png)

```javascript
//引入http模块
const http = require('http');
//app就是网络服务器对象
const app = http.createServer();
//处理请求参数的模块
const querystring = require('querystring');
//当客户端有请求来的时候 参数：req即请求 res即回应
app.on('request', (req, res) => {

    //post参数是通过事件的方式接受的
    //data 请求参数传递时
    //end 参数传递完成时
    let postParams = '';
    req.on('data', params => {
        postParams += params;
    });
    req.on('end', () => {
        // console.log(postParams);
        console.log(querystring.parse(postParams));
    });


    res.end('ok');

});
//监听端口
app.listen(3000);
console.log('服务器已启动，监听3000端口，请访问localhost:3000');
```

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <!-- method：指定当前表单提交的方式
    action：指定当前表单提交的地址 -->
    <form action="http://localhost:3000" method="POST">
        <input type="text" name="username" id="">
        <input type="password" name="password" id="">
        <input type="submit">
    </form>
</body>
</html>
```

## 2.5路由

```js
// 1 - 引入系统模块http
// 2 - 创建网站服务器
// 3 - 为服务器添加请求事件
// 4 - 实现路由功能
//     1 - 获取客户端的请求方式
//     2 - 获取客户端的请求地址
const http = require('http')
const url = require('url')

const app = http.createServer()

app.on('request', (req, res) => {
    //获取请求方式
    const method = req.method.toLowerCase()
    //获取请求地址
    const pathname = url.parse(req.url).pathname
    //对响应报文进行处理
    res.writeHead(200, {
        'content-type': 'text/html;charset=utf8'
    })

    if (method == 'get') {
        if (pathname == '/' || pathname == '/index') {
            res.end('欢迎来到首页！')
        } else if (pathname == '/list') {
            res.end('欢迎来到list页面！')
        } else {
            res.end('页面不存在')
        }
    } else if (method == 'post') {
        // res.end('Post')
    }


})

app.listen(3000)
console.log('服务器创建成功！端口3000，祝君好运！');
```

## 2.6静态文件访问

```js
const http = require('http')
const url = require('url')
const path = require('path')
const fs = require('fs')
const mime = require('mime') //第三方模块

const app = http.createServer()

app.on('request', (req, res) => {
    //获取用户请求路径
    let pathname = url.parse(req.url).pathname
    //当pathname是斜杠时
    pathname = pathname == '/' ? '/default.html' : pathname
    //用path拼接实际请求路径
    let realPath = path.join(__dirname, 'public', pathname)
    //利用mime第三方模块来获取文件类型
    let type = mime.getType(realPath)
    //读取实际路径内容
    fs.readFile(realPath, (error, result) => {
        //error时
        if (error != null) {
            res.writeHead(404, {
                'content-type': 'text/html;charset=utf8'
            })
            res.end('文件请求失败')
            return
        }
        //成功时
        res.writeHead(200, {
            'content-type': type
        })
        res.end(result)
    })
})

app.listen(3000)
console.log('服务器创建成功！端口3000，祝君好运！');
```

# 3.**异步编程**

代码执行顺序：先执行同步，同步执行完毕后再执行异步

## 3.1同步API 异步API

![image-20210124144319184](assets.%E7%AC%94%E8%AE%B0/image-20210124144319184.png)

## 3.2通过回调函数获取值

```js
function getMsg(callback) {
    setTimeout(() => {
        callback({
            msg: 'Hello'
        })
    }, 2000);
}

getMsg(msg => {
    console.log(msg) //输出：{ msg: 'Hello' }
})

```

## 3.3Promise解决回调地狱的问题

![image-20210124153250798](assets.%E7%AC%94%E8%AE%B0/image-20210124153250798.png)

## 3.4Promise按照顺序执行异步程序

```js
const fs = require('fs')
//要求按照顺序执行异步程序
function p1() {
    return new Promise((resolve, reject) => {
        fs.readFile('./1.txt', 'utf8', (error, result1) => {
            if (error != null) {
                reject(error)
            } else {
                resolve(result1)
            }
        })
    })
}

function p2() {
    return new Promise((resolve, reject) => {
        fs.readFile('./2.txt', 'utf8', (error, result2) => {
            if (error != null) {
                reject(error)
            } else {
                resolve(result2)
            }
        })
    })
}

function p3() {
    return new Promise((resolve, reject) => {
        fs.readFile('./3.txt', 'utf8', (error, result3) => {
            if (error != null) {
                reject(error)
            } else {
                resolve(result3)
            }
        })
    })
}
//通过这种方法可以保证按照顺序执行
p1().then(result => {
    console.log(result);
    return p2();
})
.catch(err => {
    console.log(err);
    return p2();
}) // return这个p2()，那么接下来可以利用链式编程来进行快捷then
.then(result => {
    console.log(result);
    return p3();
})
.catch(err => {
    console.log(err);
    return p3();
})
.then(result => {
    console.log(result);
})
.catch(err => {
    console.log(err);
})
// p1().then(result => {
//         console.log(result);
//     })
//     .catch(err => {
//         console.log(err);
//     })
// p2().then(result => {
//         console.log(result);
//     })
//     .catch(err => {
//         console.log(err);
//     })
// p3().then(result => {
//         console.log(result);
//     })
//     .catch(err => {
//         console.log(err);
//     })
```

## 3.5异步函数，终极解决方式（ES7新加入）

### 3.5.1简介

![image-20210124161152048](assets.%E7%AC%94%E8%AE%B0/image-20210124161152048.png)

### 3.5.2基础语法

```javascript
// 1.在普通函数定义的前面加上async关键字 普通函数就变成了异步函数
// 2.异步函数默认的返回值是promise对象
// 3.在异步函数内部使用throw关键字进行错误的抛出
// 
// await关键字
// 1.它只能出现在异步函数中
// 2.await promise 它可以暂停异步函数的执行 等待promise对象返回结果后再向下执行函数

//基础语法
// async function fn() {
//     throw '发生了一些错误'; //throw之后的代码不会执行
//     return 123;
// }
// fn ().then(function (data) {
// 	console.log(data);
// }).catch(function (err){
// 	console.log(err);
// })

async function p1() {
    return 'p1';
}
async function p2() {
    return 'p2';
}
async function p3() {
    return 'p3';
}
async function run() {
    let r1 = await p1()
    let r2 = await p2()
    let r3 = await p3()
    console.log(r1)
    console.log(r2)
    console.log(r3)
}
run();
```

### 3.5.3改造现有的异步API  -（promisify）

```js
const fs = require('fs');

// 改造现有异步函数api 让其返回promise对象 从而支持异步函数语法
const promisify = require('util').promisify;
// 调用promisify方法改造现有异步API 让其返回promise对象
const readFile = promisify(fs.readFile);

async function run () {
	let r1 = await readFile('./1.txt', 'utf8')
	let r2 = await readFile('./2.txt', 'utf8')
	let r3 = await readFile('./3.txt', 'utf8')
	console.log(r1)
	console.log(r2)
	console.log(r3)
}

run();
```

# 4.**数据库 - MongoDB**

## 4.1基础操作

### 4.1.1相关概念

|    术语    |                         解释说明                         |
| :--------: | :------------------------------------------------------: |
|  database  | 数据库，mongoDB数据库软件中可以建立多个数据库       |
| collection | 集合，一组数据的集合，可以理解为JavaScript中的数组    |
|  document  | 文档，一条具体的数据，可以理解为JavaScript中的对象    |
|   field    | 字段，文档中的属性名称，可以理解为JavaScript中的对象属性 |

### 4.1.2第三方模块Mongoose

```
npm intall mongoose
```

### 4.1.3启动MongoDB

```
//注：需要管理员权限
//启动MongoDB
net start mongodb

//停止MongoDB
net stop mongodb
```

### 4.1.4数据库连接

使用mongoose提供的connect方法即可连接数据库

```js
const mongoose = require('mongoose')

mongoose.connect('mongodb://localhost/playground', {
        useNewUrlParser: true,
        useUnifiedTopology: true
    })
    .then(() => console.log('数据库连接成功'))
    .catch(err => console.log(err, '数据库连接失败'));
```

### 4.1.5创建数据库

在MongoDB中不需要显式创建数据库，如果正在使用的数据库不存在，MongoDB会自动创建。

## 4.2增删查改操作

### 4.2.1创建集合

```js
//引入第三方模块mongoose，以操作数据库
const mongoose = require('mongoose')
//数据库连接
mongoose.connect('mongodb://localhost/playground', {
        useNewUrlParser: true,
        useUnifiedTopology: true
    })
    .then(() => console.log('数据库连接成功'))
    .catch(err => console.log(err, '数据库连接失败'));

//创建集合分两步
//1.创建集合规则
const courseSchema = new mongoose.Schema({
    name: String,
    author: String,
    isPublished:Boolean
})
//2.使用规则创建集合（同时也是构造函数）
const Course = mongoose.model('Course',courseSchema) //courses
```

### 4.2.2创建文档

```js
//创建文档 方法一
//	1.利用构造函数插入文档
const course = new Course({
    name: '太虚苍蓝闪',
    author: 'キョウカ',
    isPublished: true
})
//	2.保存文档 即 将文档插入数据库中
course.save()

//-----

//创建文档 方法二
Course.create({
    name: '如何辨别可疑变态分子',
    author: 'キョウカ',
    isPublished: true
}, (err, result) => {
        console.log(err);       //错误对象
        console.log(result);    //插入的文档对象
})

//-----

//创建文档 方法三
Course.create({
        name: '喷水萝莉是怎样炼成的',
        author: 'キョウカ',
        isPublished: true
    })
    .then(doc => console.log(doc))
    .catch(err => console.log(err))
```

### 4.2.3导入文件操作

```
mongoimport -d 数据库名 -c 集合名 --file 要导入的数据文件
//先找到mongodb数据库的安装目录，将bin目录放置在环境变量中
```

### 4.2.4查询文档

```js
// 查询所有文档			
User.find().then(result=>console.log(result))	//返回数组
// 通过字段去查询所有文档		
User.find({_id: '5c09f267aeb04b22f8460968'}).then(res => console.log(res))	//返回数组
// 查询用户集合中年龄字段大于20并且小于40的文档
User.find({age: {$gt: 20, $lt: 40}}).then(result => console.log(result))	//返回数组
// 查询用户集合中hobbies字段值包含足球的文档
User.find({hobbies: {$in: ['足球']}}).then(result => console.log(result))	//返回数组
// 选择要查询的字段 （不加上 -_id 会默认包含查找id）
User.find().select('name email -_id').then(result => console.log(result))	//返回数组
// 根据年龄字段进行升序排列
User.find().sort('age').then(result => console.log(result))	//返回数组
// 根据年龄字段进行降序排列
User.find().sort('-age').then(result => console.log(result))	//返回数组
// 查询文档跳过前两条结果 限制显示3条结果
User.find().skip(2).limit(3).then(result => console.log(result))	//返回数组

// findOne方法返回一条文档 默认返回当前集合中的第一条文档
User.findOne({name: '李四'}).then(result => console.log(result))	//返回对象
```

### 4.2.5删除文档

![image-20210124210310938](assets.%E7%AC%94%E8%AE%B0/image-20210124210310938.png)

删除单个返回值：删除的对象
删除多个返回这：｛n:3,ok:1｝n为删除了几个对象，ok为1时表示删除成功

### 4.2.6更新文档

![image-20210124212828447](assets.%E7%AC%94%E8%AE%B0/image-20210124212828447.png)

### 4.2.7 mongoose验证

![image-20210124220641012](assets.%E7%AC%94%E8%AE%B0/image-20210124220641012.png)

```js
const postSchema = new mongoose.Schema({
    title: {
        type: String,
        //第二个参数可以自定义报错信息
        //require: true 这样的话，如果不传title会报错 (必选字段)
        required: [true, '未传入文章标题(#`O′)'],
        //minlength最小长度 maxlength最大长度
        minlength: [2, '长度小于2(#`O′)'],
        maxlength: [5, '长度大于5(#`O′)'],
        //trim去除字符串两边的空格
        trim: true
    },
    age: {
        type: Number,
        //min,max限制数组类型的值的大小
        min: 18,
        max: 100
    },
    publishDate: {
        type: Date,
        //默认值
        default: Date.now
    },
    category: {
        type: String,
        //只能传，枚举中的值
        enum: ['html', 'css', 'js', 'ts']
    },
    author: {
        type: String,
        validate: {
            validator: v => {
                //返回布尔值，true为验证成功，false反之
                //v是传入的值
                return v && v.length > 4
            },
            //自定义错误信息
            message: '传入的值不符合规则'
        }
    }
})
const Post = mongoose.model('Post', postSchema)
```

#### 自定义错误信息

![image-20210124221145532](assets.%E7%AC%94%E8%AE%B0/image-20210124221145532.png)

![image-20210124221201404](assets.%E7%AC%94%E8%AE%B0/image-20210124221201404.png)

