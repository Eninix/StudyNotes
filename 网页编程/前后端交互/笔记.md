# **1.Node.js**

## 1.1模块化

### 1.1.1自己的模块

![image-20210120172305842](assets.%E7%AC%94%E8%AE%B0/image-20210120172305842.png)![image-20210120172325805](assets.%E7%AC%94%E8%AE%B0/image-20210120172325805.png)![image-20210120172344485](assets.%E7%AC%94%E8%AE%B0/image-20210120172344485.png)



### 1.1.2系统模块 fs - 文件操作

#### 读取文件

![image-20210120172518141](assets.%E7%AC%94%E8%AE%B0/image-20210120172518141.png)

![image-20210120172620071](assets.%E7%AC%94%E8%AE%B0/image-20210120172620071.png)

#### 写入文件

![image-20210120173549334](assets.%E7%AC%94%E8%AE%B0/image-20210120173549334.png)

### 1.1.3系统文件 path - 路径操作

#### 路径拼接

![image-20210120175725600](assets.%E7%AC%94%E8%AE%B0/image-20210120175725600.png)

#### 相对路径与绝对路径

![image-20210120175922648](assets.%E7%AC%94%E8%AE%B0/image-20210120175922648.png)

## 1.2第三方模块 nodemon 保存后自动运行

![image-20210120181708589](assets.%E7%AC%94%E8%AE%B0/image-20210120181708589.png)

## 1.3第三方模块 nrm 切换国内下载地址

![image-20210120182005767](assets.%E7%AC%94%E8%AE%B0/image-20210120182005767.png)

## 1.4第三方模块 gulp

![image-20210120182916245](assets.%E7%AC%94%E8%AE%B0/image-20210120182916245.png)

![image-20210120183747401](assets.%E7%AC%94%E8%AE%B0/image-20210120183747401.png)

### 初次使用

![image-20210120184939686](assets.%E7%AC%94%E8%AE%B0/image-20210120184939686.png)

![image-20210120184859782](assets.%E7%AC%94%E8%AE%B0/image-20210120184859782.png)

### 新版本写法

![image-20210120201637604](assets.%E7%AC%94%E8%AE%B0/image-20210120201637604.png)

### gulp插件

![image-20210120185054619](assets.%E7%AC%94%E8%AE%B0/image-20210120185054619.png)

### 压缩html文件 gulp-htmlmin

需要在gulpfile.js中这样写道

![image-20210120191729326](assets.%E7%AC%94%E8%AE%B0/image-20210120191729326.png)

![image-20210120191654988](assets.%E7%AC%94%E8%AE%B0/image-20210120191654988.png)



### 抽取公共部分 gulp-file-include

需要在gulpfile.js中这样写道

![image-20210120191810010](assets.%E7%AC%94%E8%AE%B0/image-20210120191810010.png)

![image-20210120191903195](assets.%E7%AC%94%E8%AE%B0/image-20210120191903195.png)

需要在html中这样书写公共部分，将公共部分单独建立文件，可同时插入到多个html中

![image-20210120192048251](assets.%E7%AC%94%E8%AE%B0/image-20210120192048251.png)

### 压缩less与css

向安装下列插件

![image-20210120192801351](assets.%E7%AC%94%E8%AE%B0/image-20210120192801351.png)

需要在gulpfile.js中这样写道

![image-20210120192717437](assets.%E7%AC%94%E8%AE%B0/image-20210120192717437.png)

![image-20210120192900861](assets.%E7%AC%94%E8%AE%B0/image-20210120192900861.png)

### js语法转换

*向安装下列插件*

npm install gulp-babel @babel/core @babel/preset-env

```
npm install --save-dev gulp-babel @babel/core @babel/preset-env
```

npm install gulp-uglify

需要在gulpfile.js中这样写道

![image-20210120194148099](assets.%E7%AC%94%E8%AE%B0/image-20210120194148099.png)

![image-20210120194457041](assets.%E7%AC%94%E8%AE%B0/image-20210120194457041.png)

![image-20210120194523610](assets.%E7%AC%94%E8%AE%B0/image-20210120194523610.png)

### 复制文件夹

即什么都不做，直接dest

![image-20210120200412150](assets.%E7%AC%94%E8%AE%B0/image-20210120200412150.png)

### 构建任务

![image-20210120201540044](assets.%E7%AC%94%E8%AE%B0/image-20210120201540044.png)

## 1.5package.json文件

使用 npm init -y快速生成该文件
记录了项目使用的模块及其相应的版本
通过 npm install 可以快速下载package.json中记录的相应版本模块

### 项目依赖和开发依赖

npm install						会下载全部的依赖
npm install --production	只下载项目依赖

![image-20210122161144397](assets.%E7%AC%94%E8%AE%B0/image-20210122161144397.png)

### 起别名批量执行代码

使用“npm run 别名“即可执行代码

![image-20210122163840143](assets.%E7%AC%94%E8%AE%B0/image-20210122163840143.png)

## 1.6Node.js模块查找机制

![image-20210122164136798](assets.%E7%AC%94%E8%AE%B0/image-20210122164136798.png)

![image-20210122180038220](assets.%E7%AC%94%E8%AE%B0/image-20210122180038220.png)

# 2.服务器与客户端

## 2.1创建Web服务器

![image-20210122183951936](assets.%E7%AC%94%E8%AE%B0/image-20210122183951936.png)![image-20210122193506300](assets.%E7%AC%94%E8%AE%B0/image-20210122193506300.png)

## 2.2请求报文

![image-20210122193136965](assets.%E7%AC%94%E8%AE%B0/image-20210122193136965.png)

![image-20210122195747217](assets.%E7%AC%94%E8%AE%B0/image-20210122195747217.png)![image-20210122195802074](assets.%E7%AC%94%E8%AE%B0/image-20210122195802074.png)

## 2.3响应报文

![image-20210122200720418](assets.%E7%AC%94%E8%AE%B0/image-20210122200720418.png)

![image-20210123133717377](assets.%E7%AC%94%E8%AE%B0/image-20210123133717377.png)

## 2.4请求参数

### get请求参数

![image-20210123140112320](assets.%E7%AC%94%E8%AE%B0/image-20210123140112320.png)

![image-20210123135929819](assets.%E7%AC%94%E8%AE%B0/image-20210123135929819.png)

### post请求参数

![image-20210123144234573](assets.%E7%AC%94%E8%AE%B0/image-20210123144234573.png)

```javascript
//引入http模块
const http = require('http');
//app就是网络服务器对象
const app = http.createServer();
//处理请求参数的模块
const querystring = require('querystring');
//当客户端有请求来的时候 参数：req即请求 res即回应
app.on('request', (req, res) => {

    //post参数是通过事件的方式接受的
    //data 请求参数传递时
    //end 参数传递完成时
    let postParams = '';
    req.on('data', params => {
        postParams += params;
    });
    req.on('end', () => {
        // console.log(postParams);
        console.log(querystring.parse(postParams));
    });


    res.end('ok');

});
//监听端口
app.listen(3000);
console.log('服务器已启动，监听3000端口，请访问localhost:3000');
```

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <!-- method：指定当前表单提交的方式
    action：指定当前表单提交的地址 -->
    <form action="http://localhost:3000" method="POST">
        <input type="text" name="username" id="">
        <input type="password" name="password" id="">
        <input type="submit">
    </form>
</body>
</html>
```

## 2.5路由

```js
// 1 - 引入系统模块http
// 2 - 创建网站服务器
// 3 - 为服务器添加请求事件
// 4 - 实现路由功能
//     1 - 获取客户端的请求方式
//     2 - 获取客户端的请求地址
const http = require('http')
const url = require('url')

const app = http.createServer()

app.on('request', (req, res) => {
    //获取请求方式
    const method = req.method.toLowerCase()
    //获取请求地址
    const pathname = url.parse(req.url).pathname
    //对响应报文进行处理
    res.writeHead(200, {
        'content-type': 'text/html;charset=utf8'
    })

    if (method == 'get') {
        if (pathname == '/' || pathname == '/index') {
            res.end('欢迎来到首页！')
        } else if (pathname == '/list') {
            res.end('欢迎来到list页面！')
        } else {
            res.end('页面不存在')
        }
    } else if (method == 'post') {
        // res.end('Post')
    }


})

app.listen(3000)
console.log('服务器创建成功！端口3000，祝君好运！');
```

## 2.6静态文件访问

```js
const http = require('http')
const url = require('url')
const path = require('path')
const fs = require('fs')
const mime = require('mime') //第三方模块

const app = http.createServer()

app.on('request', (req, res) => {
    //获取用户请求路径
    let pathname = url.parse(req.url).pathname
    //当pathname是斜杠时
    pathname = pathname == '/' ? '/default.html' : pathname
    //用path拼接实际请求路径
    let realPath = path.join(__dirname, 'public', pathname)
    //利用mime第三方模块来获取文件类型
    let type = mime.getType(realPath)
    //读取实际路径内容
    fs.readFile(realPath, (error, result) => {
        //error时
        if (error != null) {
            res.writeHead(404, {
                'content-type': 'text/html;charset=utf8'
            })
            res.end('文件请求失败')
            return
        }
        //成功时
        res.writeHead(200, {
            'content-type': type
        })
        res.end(result)
    })
})

app.listen(3000)
console.log('服务器创建成功！端口3000，祝君好运！');
```

# 3.异步编程

代码执行顺序：先执行同步，同步执行完毕后再执行异步

## 3.1同步API 异步API

![image-20210124144319184](assets.%E7%AC%94%E8%AE%B0/image-20210124144319184.png)

## 3.2通过回调函数获取值

```js
function getMsg(callback) {
    setTimeout(() => {
        callback({
            msg: 'Hello'
        })
    }, 2000);
}

getMsg(msg => {
    console.log(msg) //输出：{ msg: 'Hello' }
})

```

## 3.3Promise解决回调地狱的问题

![image-20210124153250798](assets.%E7%AC%94%E8%AE%B0/image-20210124153250798.png)

## 3.4Promise按照顺序执行异步程序

```js
const fs = require('fs')
//要求按照顺序执行异步程序
function p1() {
    return new Promise((resolve, reject) => {
        fs.readFile('./1.txt', 'utf8', (error, result1) => {
            if (error != null) {
                reject(error)
            } else {
                resolve(result1)
            }
        })
    })
}

function p2() {
    return new Promise((resolve, reject) => {
        fs.readFile('./2.txt', 'utf8', (error, result2) => {
            if (error != null) {
                reject(error)
            } else {
                resolve(result2)
            }
        })
    })
}

function p3() {
    return new Promise((resolve, reject) => {
        fs.readFile('./3.txt', 'utf8', (error, result3) => {
            if (error != null) {
                reject(error)
            } else {
                resolve(result3)
            }
        })
    })
}
//通过这种方法可以保证按照顺序执行
p1().then(result => {
    console.log(result);
    return p2();
})
.catch(err => {
    console.log(err);
    return p2();
}) // return这个p2()，那么接下来可以利用链式编程来进行快捷then
.then(result => {
    console.log(result);
    return p3();
})
.catch(err => {
    console.log(err);
    return p3();
})
.then(result => {
    console.log(result);
})
.catch(err => {
    console.log(err);
})
// p1().then(result => {
//         console.log(result);
//     })
//     .catch(err => {
//         console.log(err);
//     })
// p2().then(result => {
//         console.log(result);
//     })
//     .catch(err => {
//         console.log(err);
//     })
// p3().then(result => {
//         console.log(result);
//     })
//     .catch(err => {
//         console.log(err);
//     })
```

## 3.5异步函数，终极解决方式（ES7新加入）

### 3.5.1简介

![image-20210124161152048](assets.%E7%AC%94%E8%AE%B0/image-20210124161152048.png)

### 3.5.2基础语法

```javascript
// 1.在普通函数定义的前面加上async关键字 普通函数就变成了异步函数
// 2.异步函数默认的返回值是promise对象
// 3.在异步函数内部使用throw关键字进行错误的抛出
// 
// await关键字
// 1.它只能出现在异步函数中
// 2.await promise 它可以暂停异步函数的执行 等待promise对象返回结果后再向下执行函数

//基础语法
// async function fn() {
//     throw '发生了一些错误'; //throw之后的代码不会执行
//     return 123;
// }
// fn ().then(function (data) {
// 	console.log(data);
// }).catch(function (err){
// 	console.log(err);
// })

async function p1() {
    return 'p1';
}
async function p2() {
    return 'p2';
}
async function p3() {
    return 'p3';
}
async function run() {
    let r1 = await p1()
    let r2 = await p2()
    let r3 = await p3()
    console.log(r1)
    console.log(r2)
    console.log(r3)
}
run();
```

### 3.5.3改造现有的异步API  -（promisify）

```js
const fs = require('fs');

// 改造现有异步函数api 让其返回promise对象 从而支持异步函数语法
const promisify = require('util').promisify;
// 调用promisify方法改造现有异步API 让其返回promise对象
const readFile = promisify(fs.readFile);

async function run () {
	let r1 = await readFile('./1.txt', 'utf8')
	let r2 = await readFile('./2.txt', 'utf8')
	let r3 = await readFile('./3.txt', 'utf8')
	console.log(r1)
	console.log(r2)
	console.log(r3)
}

run();
```

# 4.数据库 - MongoDB

## 4.1相关概念

|    术语    |                         解释说明                         |
| :--------: | :------------------------------------------------------: |
|  database  | 数据库，mongoDB数据库软件中可以建立多个数据库       |
| collection | 集合，一组数据的集合，可以理解为JavaScript中的数组    |
|  document  | 文档，一条具体的数据，可以理解为JavaScript中的对象    |
|   field    | 字段，文档中的属性名称，可以理解为JavaScript中的对象属性 |

